---
title: "simple_matching_diffndiff"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_knit$set(root.dir = normalizePath("C:/Users/tenis/Desktop/Data_Projects/UT_Lab-Matching")) 
```

## Simple Matching and Diff n Diff

Because there are so many different time period, I'm going to break up the evaluation down to simple parts

```{r libraries, message=TRUE, warning=TRUE, include=FALSE}

library(tidyverse)
library(readr)
library(readxl)
library(janitor)
library(Matching)
library(rbounds)
```

## IPD Data

```{r ipd, message=TRUE, warning=TRUE, include=FALSE}

ipd_raw <-
  read_csv("data/interim/IPD_eid_list_minus2015.csv",
           col_types = cols(X1 = col_skip()))

ipd_raw <- ipd_raw %>% mutate_all( ~ gsub(" \\(R\\)| \\*Minor", "", .))

cola_raw <- read_csv("data/processed/cola_total.csv")
cola_raw <- clean_names(cola_raw)
```

**Going from long to wide to look at those that are repeaters**

```{r long2wide}

ipdlong <- ipd_raw
ipdlong <- filter(ipdlong, year != 2015)
ipdlong <- filter(ipdlong, year != "2013/2014")
ipdlong <- ipdlong[,-2]
ipdlong$binary <- 1

ipdwide <- pivot_wider(ipdlong, names_from = year, values_from = binary) 
ipdwide[is.na(ipdwide)] <- 0
ipdwide$total_years <- rowSums(ipdwide[,c("2016","2017","2018","2019","2020")])

ipdmultiples <- filter(ipdwide, total_years > 1)
ipdmultiples_eids <- ipdmultiples$eid

#Removing students who have multiple years 
ipd_minus_multiples <- ipd_raw %>% filter(!eid %in% ipdmultiples_eids)


```

Based on the row sums, there are quite a few students who returned for multiple years. In order to save my sanity, I'm going to look at 2017 first.

**2017**

```{r 2017}


df <- filter(ipd_minus_multiples, year == 2017)
cola_before <- filter(cola_raw, semester == "Fall 2016")
df <- left_join(df,cola_before, by = "eid")
# About 10% are not in the database for the previous semester 

df_possible_freshman <- df[is.na(df$x1),]


completeFun <- function(data, desiredCols) {
  completeVec <- complete.cases(data[, desiredCols])
  return(data[completeVec, ])
}

df <- completeFun(df, "x1")

#Removing cases of people who graduated in 2016
cola_before <- filter(cola_before, academic_status != "Graduated")
df <- filter(ipd_minus_multiples, year == 2017)
cola_before <- left_join(cola_before, df, by = 'eid')
cola_before$name.y[is.na(cola_before$name.y)] <- 0
cola_before$name.y[cola_before$name.y != 0] <- 1
cola_before$name.y <- as.numeric(cola_before$name.y)
cola_before <- cola_before %>% rename("treatment" = "name.y")

cola_abb2017 <- dplyr::select(cola_before, eid, cola_abbr1)
```

**Propensity Score Matching**

```{r propensity_score}


Y <- cola_before$cumulative_gpa
Tr <- cola_before$treatment


glm1 <- glm(Tr ~ age + citizenship + gender + ethnicities + hs_rank_2 + family_income , family=binomial, data = cola_before)

# By default Match does 1-to-1 matching with replacement and estimates average treatment effect (ATT)
rr1 <- Match(Y = Y, Tr = Tr, X = glm1$fitted)

summary(rr1)

```

```{r matching_diagnostic}

qqplot(cola_before$cumulative_gpa[rr1$index.control], cola_before$cumulative_gpa[rr1$index.treated])
abline(coef = c(0, 1), col = 2)


```

**Showing the Match Balance before and after**

```{r before_after_match, message=FALSE, warning=FALSE, include=FALSE}

 #MatchBalance(Tr ~ age + citizenship + gender + ethnicities + hs_rank_2 + family_income , match.out = rr1, nboots = 1000, data = cola_before)

```

```{r sensitivity}


psens(rr1, Gamma=1.7, GammaInc=.05)
hlsens(rr1, Gamma=1.7, GammaInc=.05, .1)

```

**Creating the matched dataset for 2017**

-   Starts with gpa from Fall 2016

```{r setup_diffndiff}
treated_list <- unique(rr1$index.treated)
treated <- cola_before[treated_list, ]
control_list <- unique(rr1$index.control)
control <- cola_before[control_list, ]

df <-
  treated %>% bind_rows(control) %>% dplyr::select(name.x, eid, cumulative_gpa, treatment, year) %>% rename(gpa_before = cumulative_gpa)

#add in GPA for end of 2017
cola_after <- filter(cola_raw, semester == "Fall 2017")
df <- left_join(df, cola_after, by = "eid")


#Finding the GPA's for students who graduated
df_onlyspring_raw <- df[is.na(df$x1), ]

df <- completeFun(df, "x1")
df <-
  df %>% rename(gpa_after = cumulative_gpa ) %>% dplyr::select(name.x, eid, gpa_before, gpa_after, treatment, year)
df$year <- 2017

df_before <-
  df %>% dplyr::select(name.x, eid, gpa_before, treatment, year) %>% rename(time = year, gpa = gpa_before) %>% mutate(time = 0, treatment_strength = 0)

df_after <-
  df %>% dplyr::select(name.x, eid, gpa_after, treatment, year) %>% rename(time = year, gpa = gpa_after) %>% mutate(time = 1)
df_after$treatment_strength <- ifelse(df$treatment == 1, 2,0)


df17_two_semesters <- bind_rows(df_before, df_after)



```

**Find matches for those that graduated halfway**

```{r graduate_spring2017, include=FALSE}

df_onlyspring <-
  df_onlyspring_raw %>% filter(treatment == 1) %>% dplyr::select(name.x, eid) %>% rename(name = name.x)
cola_before <- filter(cola_raw, semester == "Fall 2016")
cola_before <- mutate(cola_before, year = 2017)



#Removing cases of people who graduated in 2016
cola_before <- filter(cola_before, academic_status != "Graduated")
cola_before <- left_join(cola_before, df_onlyspring, by = 'eid')
cola_before$name.y[is.na(cola_before$name.y)] <- 0
cola_before$name.y[cola_before$name.y != 0] <- 1
cola_before$name.y <- as.numeric(cola_before$name.y)
cola_before <- cola_before %>% rename("treatment" = "name.y")

cola_abb2017spring <- dplyr::select(cola_before, eid, cola_abbr1)

Y <- cola_before$cumulative_gpa
Tr <- cola_before$treatment


glm1 <- glm(Tr ~ age + citizenship + gender + ethnicities + hs_rank_2 + family_income , family=binomial, data = cola_before)

# By default Match does 1-to-1 matching with replacement and estimates average treatment effect (ATT)
rr1 <- Match(Y = Y, Tr = Tr, X = glm1$fitted)

summary(rr1)

#diagnostic 
qqplot(cola_before$cumulative_gpa[rr1$index.control], cola_before$cumulative_gpa[rr1$index.treated])
abline(coef = c(0, 1), col = 2)

##MatchBalance
 #MatchBalance(Tr ~ age + citizenship + gender + ethnicities + hs_rank_2 + family_income  , match.out = rr1, nboots = 1000, data = cola_before)
 
#pulling the after gpa
 treated_list <- unique(rr1$index.treated)
treated <- cola_before[treated_list, ]
control_list <- unique(rr1$index.control)
control <- cola_before[control_list, ]

df_spring <-
  treated %>% bind_rows(control) %>% dplyr::select(name.x, eid, cumulative_gpa, treatment, year) %>% rename(gpa_before = cumulative_gpa)

#add in GPA for end of 2017
cola_after_spring <- filter(cola_raw, semester == "Spring 2017")
df_spring <- left_join(df_spring, cola_after_spring, by = "eid")



df_spring <- completeFun(df_spring, "x1")
df_spring <-
  df_spring %>% rename(gpa_after = cumulative_gpa ) %>% dplyr::select(name.x, eid, gpa_before, gpa_after, treatment, year)
df_spring$year <- 2017

df_before <-
  df_spring %>% dplyr::select(name.x, eid, gpa_before, treatment, year) %>% rename(time = year, gpa = gpa_before) %>% mutate(time = 0, treatment_strength = 0)

df_after <-
  df_spring %>% dplyr::select(name.x, eid, gpa_after, treatment, year) %>% rename(time = year, gpa = gpa_after) %>% mutate(time = 1)
df_after$treatment_strength <- ifelse(df_spring$treatment == 1, 1,0)

df17_spring <- bind_rows(df_before, df_after)
```

**Four semesters**

```{r multiple2017}

df_twoyears <-
  ipdmultiples %>% filter(`2017` == 1 &
                            `2018` == 1) %>% dplyr::select(name, eid)
df_threeyears <-
  ipdmultiples %>% filter(`2017` == 1 &
                           `2018` == 1 &
                           `2019` == 1) %>% dplyr::select(name, eid)


cola_before <- filter(cola_raw, semester == "Fall 2016")
cola_before <- mutate(cola_before, year = 2017)



#Removing cases of people who graduated in 2016 and those that are seniors so there is not a lot of blanks for the after gpa match
cola_before <- filter(cola_before, academic_status != "Graduated" & classification != "Senior")
cola_before <- left_join(cola_before, df_twoyears, by = 'eid')
cola_before$name.y[is.na(cola_before$name.y)] <- 0
cola_before$name.y[cola_before$name.y != 0] <- 1
cola_before$name.y <- as.numeric(cola_before$name.y)
cola_before <- cola_before %>% rename("treatment" = "name.y")

cola_abb20174 <- dplyr::select(cola_before, eid, cola_abbr1)

Y <- cola_before$cumulative_gpa
Tr <- cola_before$treatment


glm1 <- glm(Tr ~ age + citizenship + gender + ethnicities + hs_rank_2 + family_income , family=binomial, data = cola_before)

# By default Match does 1-to-1 matching with replacement and estimates average treatment effect (ATT)
rr1 <- Match(Y = Y, Tr = Tr, X = glm1$fitted)

summary(rr1)

#diagnostic 
qqplot(cola_before$cumulative_gpa[rr1$index.control], cola_before$cumulative_gpa[rr1$index.treated])
abline(coef = c(0, 1), col = 2)

##MatchBalance
 #MatchBalance(Tr ~ age + citizenship + gender + ethnicities + hs_rank_2 + family_income  , match.out = rr1, nboots = 1000, data = cola_before)
 
#pulling the after gpa
 treated_list <- unique(rr1$index.treated)
treated <- cola_before[treated_list, ]
control_list <- unique(rr1$index.control)
control <- cola_before[control_list, ]

df <-
  treated %>% bind_rows(control) %>% dplyr::select(name.x, eid, cumulative_gpa, treatment, year) %>% rename(gpa_before = cumulative_gpa)

#add in GPA for end of 2018
cola_after <- filter(cola_raw, semester == "Fall 2018")
df <- left_join(df, cola_after, by = "eid")

#Finding the GPA's for students who graduated
df_three_semesters_raw <- df[is.na(df$x1), ]

df <- completeFun(df, "x1")
df <-
  df %>% rename(gpa_after = cumulative_gpa ) %>% dplyr::select(name.x, eid, gpa_before, gpa_after, treatment, year)
df$year <- 2017

df_before <-
  df %>% dplyr::select(name.x, eid, gpa_before, treatment, year) %>% rename(time = year, gpa = gpa_before) %>% mutate(time = 0, treatment_strength = 0)

df_after <-
  df %>% dplyr::select(name.x, eid, gpa_after, treatment, year) %>% rename(time = year, gpa = gpa_after) %>% mutate(time = 1)
df_after$treatment_strength <- ifelse(df$treatment == 1, 4,0)

df17_four_semesters <- bind_rows(df_before, df_after)

```

**Three Semesters starting in 2017**

-   There was only on that had three semesters, so I removed her (Paula Benavides)

**2018**

```{r 2018}

df <- filter(ipd_minus_multiples, year == 2018)
cola_before <- filter(cola_raw, semester == "Fall 2017")
df <- left_join(df,cola_before, by = "eid")
# About 10% are not in the database for the previous semester 

df_possible_freshman <- df[is.na(df$x1),]


completeFun <- function(data, desiredCols) {
  completeVec <- complete.cases(data[, desiredCols])
  return(data[completeVec, ])
}

df <- completeFun(df, "x1")

#Removing cases of people who graduated in 2016
cola_before <- filter(cola_before, academic_status != "Graduated")
df <- filter(ipd_minus_multiples, year == 2018)
cola_before <- left_join(cola_before, df, by = 'eid')
cola_before$name.y[is.na(cola_before$name.y)] <- 0
cola_before$name.y[cola_before$name.y != 0] <- 1
cola_before$name.y <- as.numeric(cola_before$name.y)
cola_before <- cola_before %>% rename("treatment" = "name.y")
cola_abb2018 <- dplyr::select(cola_before, eid, cola_abbr1)

############################Propensity Score Matching############################
Y <- cola_before$cumulative_gpa
Tr <- cola_before$treatment


glm1 <- glm(Tr ~ age + citizenship + gender + ethnicities + hs_rank_2 + family_income , family=binomial, data = cola_before)

# By default Match does 1-to-1 matching with replacement and estimates average treatment effect (ATT)
rr1 <- Match(Y = Y, Tr = Tr, X = glm1$fitted)

summary(rr1)

#Matching Diagnostic 
qqplot(cola_before$cumulative_gpa[rr1$index.control], cola_before$cumulative_gpa[rr1$index.treated])
abline(coef = c(0, 1), col = 2)


#Match Balance
 #MatchBalance(Tr ~ age + citizenship + gender + ethnicities + hs_rank_2 + family_income , match.out = rr1, nboots = 1000, data = cola_before)
 
#Grabbing After gpa  
treated_list <- unique(rr1$index.treated)
treated <- cola_before[treated_list, ]
control_list <- unique(rr1$index.control)
control <- cola_before[control_list, ]

df <-
  treated %>% bind_rows(control) %>% dplyr::select(name.x, eid, cumulative_gpa, treatment, year) %>% rename(gpa_before = cumulative_gpa)

#add in GPA for end of 2017
cola_after <- filter(cola_raw, semester == "Fall 2018")
df <- left_join(df, cola_after, by = "eid")


#Finding the GPA's for students who graduated
df_onlyspring_raw <- df[is.na(df$x1), ]

df <- completeFun(df, "x1")
df <-
  df %>% rename(gpa_after = cumulative_gpa ) %>% dplyr::select(name.x, eid, gpa_before, gpa_after, treatment, year)
df$year <- 2018

df_before <-
  df %>% dplyr::select(name.x, eid, gpa_before, treatment, year) %>% rename(time = year, gpa = gpa_before) %>% mutate(time = 0, treatment_strength = 0)

df_after <-
  df %>% dplyr::select(name.x, eid, gpa_after, treatment, year) %>% rename(time = year, gpa = gpa_after) %>% mutate(time = 1)
df_after$treatment_strength <- ifelse(df$treatment == 1, 2,0)


df18_two_semesters <- bind_rows(df_before, df_after)



####################################One Semester###################################
df_onlyspring <-
  df_onlyspring_raw %>% filter(treatment == 1) %>% dplyr::select(name.x, eid) %>% rename(name = name.x)
cola_before <- filter(cola_raw, semester == "Fall 2017")
cola_before <- mutate(cola_before, year = 2018)



#Removing cases of people who graduated in 2016
cola_before <- filter(cola_before, academic_status != "Graduated")
cola_before <- left_join(cola_before, df_onlyspring, by = 'eid')
cola_before$name.y[is.na(cola_before$name.y)] <- 0
cola_before$name.y[cola_before$name.y != 0] <- 1
cola_before$name.y <- as.numeric(cola_before$name.y)
cola_before <- cola_before %>% rename("treatment" = "name.y")
cola_abb2018spring <- dplyr::select(cola_before, eid, cola_abbr1)

Y <- cola_before$cumulative_gpa
Tr <- cola_before$treatment


glm1 <- glm(Tr ~ age + citizenship + gender + ethnicities + hs_rank_2 + family_income , family=binomial, data = cola_before)

# By default Match does 1-to-1 matching with replacement and estimates average treatment effect (ATT)
rr1 <- Match(Y = Y, Tr = Tr, X = glm1$fitted)

summary(rr1)

#diagnostic 
qqplot(cola_before$cumulative_gpa[rr1$index.control], cola_before$cumulative_gpa[rr1$index.treated])
abline(coef = c(0, 1), col = 2)

##MatchBalance
 #MatchBalance(Tr ~ age + citizenship + gender + ethnicities + hs_rank_2 + family_income  , match.out = rr1, nboots = 1000, data = cola_before)
 
#pulling the after gpa
 treated_list <- unique(rr1$index.treated)
treated <- cola_before[treated_list, ]
control_list <- unique(rr1$index.control)
control <- cola_before[control_list, ]

df_spring <-
  treated %>% bind_rows(control) %>% dplyr::select(name.x, eid, cumulative_gpa, treatment, year) %>% rename(gpa_before = cumulative_gpa)

#add in GPA for end of 2017
cola_after_spring <- filter(cola_raw, semester == "Spring 2018")
df_spring <- left_join(df_spring, cola_after_spring, by = "eid")


df_spring <- completeFun(df_spring, "x1")
df_spring <-
  df_spring %>% rename(gpa_after = cumulative_gpa ) %>% dplyr::select(name.x, eid, gpa_before, gpa_after, treatment, year)
df_spring$year <- 2018

df_before <-
  df_spring %>% dplyr::select(name.x, eid, gpa_before, treatment, year) %>% rename(time = year, gpa = gpa_before) %>% mutate(time = 0, treatment_strength = 0)

df_after <-
  df_spring %>% dplyr::select(name.x, eid, gpa_after, treatment, year) %>% rename(time = year, gpa = gpa_after) %>% mutate(time = 1)
df_after$treatment_strength <- ifelse(df_spring$treatment == 1, 1,0)

df18_spring <- bind_rows(df_before, df_after)

################################Four Semesters####################################
df_twoyears <-
  ipdmultiples %>% filter(`2018` == 1 &
                            `2019` == 1) %>% dplyr::select(name, eid)
df_threeyears <-
  ipdmultiples %>% filter(`2018` == 1 &
                           `2019` == 1 &
                           `2020` == 1) %>% dplyr::select(name, eid)


cola_before <- filter(cola_raw, semester == "Fall 2017")
cola_before <- mutate(cola_before, year = 2018)



#Removing cases of people who graduated in 2016 and those that are seniors so there is not a lot of blanks for the after gpa match
cola_before <- filter(cola_before, academic_status != "Graduated" & classification != "Senior")
cola_before <- left_join(cola_before, df_twoyears, by = 'eid')
cola_before$name.y[is.na(cola_before$name.y)] <- 0
cola_before$name.y[cola_before$name.y != 0] <- 1
cola_before$name.y <- as.numeric(cola_before$name.y)
cola_before <- cola_before %>% rename("treatment" = "name.y")
cola_abb20184 <- dplyr::select(cola_before, eid, cola_abbr1)

Y <- cola_before$cumulative_gpa
Tr <- cola_before$treatment


glm1 <- glm(Tr ~ age + citizenship + gender + ethnicities + hs_rank_2 + family_income , family=binomial, data = cola_before)

# By default Match does 1-to-1 matching with replacement and estimates average treatment effect (ATT)
rr1 <- Match(Y = Y, Tr = Tr, X = glm1$fitted)

summary(rr1)

#diagnostic 
qqplot(cola_before$cumulative_gpa[rr1$index.control], cola_before$cumulative_gpa[rr1$index.treated])
abline(coef = c(0, 1), col = 2)

##MatchBalance
 #MatchBalance(Tr ~ age + citizenship + gender + ethnicities + hs_rank_2 + family_income  , match.out = rr1, nboots = 1000, data = cola_before)
 
#pulling the after gpa
 treated_list <- unique(rr1$index.treated)
treated <- cola_before[treated_list, ]
control_list <- unique(rr1$index.control)
control <- cola_before[control_list, ]

df <-
  treated %>% bind_rows(control) %>% dplyr::select(name.x, eid, cumulative_gpa, treatment, year) %>% rename(gpa_before = cumulative_gpa)

#add in GPA for end of 2018
cola_after <- filter(cola_raw, semester == "Fall 2019")
df <- left_join(df, cola_after, by = "eid")

#Finding the GPA's for students who graduated
df_three_semesters_raw <- df[is.na(df$x1), ]

df <- completeFun(df, "x1")
df <-
  df %>% rename(gpa_after = cumulative_gpa ) %>% dplyr::select(name.x, eid, gpa_before, gpa_after, treatment, year)
df$year <- 2018

df_before <-
  df %>% dplyr::select(name.x, eid, gpa_before, treatment, year) %>% rename(time = year, gpa = gpa_before) %>% mutate(time = 0, treatment_strength = 0)

df_after <-
  df %>% dplyr::select(name.x, eid, gpa_after, treatment, year) %>% rename(time = year, gpa = gpa_after) %>% mutate(time = 1)
df_after$treatment_strength <- ifelse(df$treatment == 1, 4,0)

df18_four_semesters <- bind_rows(df_before, df_after)

```

**2019**

```{r 2019}

df <- filter(ipd_minus_multiples, year == 2019)
cola_before <- filter(cola_raw, semester == "Fall 2018")
df <- left_join(df,cola_before, by = "eid")
# About 10% are not in the database for the previous semester 

df_possible_freshman <- df[is.na(df$x1),]


completeFun <- function(data, desiredCols) {
  completeVec <- complete.cases(data[, desiredCols])
  return(data[completeVec, ])
}

df <- completeFun(df, "x1")

#Removing cases of people who graduated in 2019
cola_before <- filter(cola_before, academic_status != "Graduated")
df <- filter(ipd_minus_multiples, year == 2019)
cola_before <- left_join(cola_before, df, by = 'eid')
cola_before$name.y[is.na(cola_before$name.y)] <- 0
cola_before$name.y[cola_before$name.y != 0] <- 1
cola_before$name.y <- as.numeric(cola_before$name.y)
cola_before <- cola_before %>% rename("treatment" = "name.y")
cola_abb2019 <- dplyr::select(cola_before, eid, cola_abbr1)

############################Propensity Score Matching############################
Y <- cola_before$cumulative_gpa
Tr <- cola_before$treatment


glm1 <- glm(Tr ~ age + citizenship + gender + ethnicities + hs_rank_2 + family_income , family=binomial, data = cola_before)

# By default Match does 1-to-1 matching with replacement and estimates average treatment effect (ATT)
rr1 <- Match(Y = Y, Tr = Tr, X = glm1$fitted)

summary(rr1)

#Matching Diagnostic 
qqplot(cola_before$cumulative_gpa[rr1$index.control], cola_before$cumulative_gpa[rr1$index.treated])
abline(coef = c(0, 1), col = 2)

#Match Balance
 #MatchBalance(Tr ~ age + citizenship + gender + ethnicities + hs_rank_2 + family_income , match.out = rr1, nboots = 1000, data = cola_before)
 
#Grabbing After gpa  
treated_list <- unique(rr1$index.treated)
treated <- cola_before[treated_list, ]
control_list <- unique(rr1$index.control)
control <- cola_before[control_list, ]

df <-
  treated %>% bind_rows(control) %>% dplyr::select(name.x, eid, cumulative_gpa, treatment, year) %>% rename(gpa_before = cumulative_gpa)

#add in GPA for end 
cola_after <- filter(cola_raw, semester == "Fall 2019")
df <- left_join(df, cola_after, by = "eid")


#Finding the GPA's for students who graduated
df_onlyspring_raw <- df[is.na(df$x1), ]

df <- completeFun(df, "x1")
df <-
  df %>% rename(gpa_after = cumulative_gpa ) %>% dplyr::select(name.x, eid, gpa_before, gpa_after, treatment, year)
df$year <- 2019

df_before <-
  df %>% dplyr::select(name.x, eid, gpa_before, treatment, year) %>% rename(time = year, gpa = gpa_before) %>% mutate(time = 0, treatment_strength = 0)

df_after <-
  df %>% dplyr::select(name.x, eid, gpa_after, treatment, year) %>% rename(time = year, gpa = gpa_after) %>% mutate(time = 1)
df_after$treatment_strength <- ifelse(df$treatment == 1, 2,0)


df19_two_semesters <- bind_rows(df_before, df_after)



####################################One Semester###################################
#There are not any spring only for 2019 

################################Four Semesters####################################
df_twoyears <-
  ipdmultiples %>% filter(`2019` == 1 &
                            `2020` == 1) %>% dplyr::select(name, eid)


cola_before <- filter(cola_raw, semester == "Fall 2018")
cola_before <- mutate(cola_before, year = 2019)



#Removing cases of people who graduated in 2016 and those that are seniors so there is not a lot of blanks for the after gpa match
cola_before <- filter(cola_before, academic_status != "Graduated" & classification != "Senior")
cola_before <- left_join(cola_before, df_twoyears, by = 'eid')
cola_before$name.y[is.na(cola_before$name.y)] <- 0
cola_before$name.y[cola_before$name.y != 0] <- 1
cola_before$name.y <- as.numeric(cola_before$name.y)
cola_before <- cola_before %>% rename("treatment" = "name.y")
cola_abb20194 <- dplyr::select(cola_before, eid, cola_abbr1)

Y <- cola_before$cumulative_gpa
Tr <- cola_before$treatment


glm1 <- glm(Tr ~ age + citizenship + gender + ethnicities + hs_rank_2 + family_income , family=binomial, data = cola_before)

# By default Match does 1-to-1 matching with replacement and estimates average treatment effect (ATT)
rr1 <- Match(Y = Y, Tr = Tr, X = glm1$fitted)

summary(rr1)

#diagnostic 
qqplot(cola_before$cumulative_gpa[rr1$index.control], cola_before$cumulative_gpa[rr1$index.treated])
abline(coef = c(0, 1), col = 2)

##MatchBalance
 #MatchBalance(Tr ~ age + citizenship + gender + ethnicities + hs_rank_2 + family_income  , match.out = rr1, nboots = 1000, data = cola_before)
 
#pulling the after gpa
 treated_list <- unique(rr1$index.treated)
treated <- cola_before[treated_list, ]
control_list <- unique(rr1$index.control)
control <- cola_before[control_list, ]

df <-
  treated %>% bind_rows(control) %>% dplyr::select(name.x, eid, cumulative_gpa, treatment, year) %>% rename(gpa_before = cumulative_gpa)

#add in GPA for end of 2018
cola_after <- filter(cola_raw, semester == "Fall 2020")
df <- left_join(df, cola_after, by = "eid")

#Finding the GPA's for students who graduated
df_three_semesters_raw <- df[is.na(df$x1), ]

df <- completeFun(df, "x1")
df <-
  df %>% rename(gpa_after = cumulative_gpa ) %>% dplyr::select(name.x, eid, gpa_before, gpa_after, treatment, year)
df$year <- 2019

df_before <-
  df %>% dplyr::select(name.x, eid, gpa_before, treatment, year) %>% rename(time = year, gpa = gpa_before) %>% mutate(time = 0, treatment_strength = 0)

df_after <-
  df %>% dplyr::select(name.x, eid, gpa_after, treatment, year) %>% rename(time = year, gpa = gpa_after) %>% mutate(time = 1)
df_after$treatment_strength <- ifelse(df$treatment == 1, 4,0)

df19_four_semesters <- bind_rows(df_before, df_after)

```

**DIfference in Difference**

```{r diffndiff}

df17 <- bind_rows(df17_two_semesters,df17_spring, df17_four_semesters)
df17$year <- 2017 

df18 <-  bind_rows(df18_two_semesters,df18_spring, df18_four_semesters)
df18$year <- 2018

#df19 <-  bind_rows(df19_two_semesters, df19_four_semesters)
#df19$year <- 2019


dfall <- bind_rows(df17, df18)
dfall$did <- dfall$time * dfall$treatment
didreg = lm(gpa ~ treatment + treatment_strength + time + did, data = dfall)
summary(didreg)
```

```{r regression}

before <-
  dfall %>% filter(time == 0) %>% rename("gpa_before" = "gpa") %>% dplyr::select(name.x, eid, gpa_before)

after <-
  dfall %>% filter(time == 1) %>% rename("gpa_after" = "gpa") %>% dplyr::select(name.x, eid, gpa_after, treatment, treatment_strength, year)

abbr <- bind_rows(cola_abb2017, cola_abb2017spring, cola_abb20174, cola_abb2018, cola_abb2018spring, cola_abb20184)
abbr <- unique(abbr)

reg_df <- after %>% left_join(before, by = "eid") %>% dplyr::select(eid, gpa_before, gpa_after, treatment, treatment_strength, year) %>% left_join(abbr)



#Regular regression 
reg <-
  lm(gpa_after ~ gpa_before + treatment + treatment_strength + year,
     data = reg_df)
summary(reg)

#Fixed Effects Regression (Dummary Variable)
reg_dummies <-
  lm(
    gpa_after ~ gpa_before + treatment + treatment_strength + factor(year),
    data = reg_df
  )
summary(reg_dummies)

#Within Estimator
 library(plm)
 plm <-
   plm(gpa_after ~ gpa_before + treatment + treatment_strength + factor(year),
      data = reg_df, index = "cola_abbr1", model= "within")
 summary(plm)



```
